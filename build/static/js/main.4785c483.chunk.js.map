{"version":3,"sources":["App.js","index.js"],"names":["distanceX","distanceY","theOriginalX","theOriginalY","theMoveToX","theMoveToY","activeChesses","nonActiveChesses","playerRole","socket","occupiedSpaces","adjSpaces","nextValidPath","greenWins","blackWins","io","App","props","getSpaces","spaces","y","x","push","className","value","key","location","locationX","locationY","isOccupied","isValidPath","style","width","height","margin","borderRadius","backgroundColor","zIndex","getChesses","chesses","zones","currentX","currentY","top","left","position","isSelected","isMoved","OppoValue","transformOrigin","chessMoveTo","e","document","querySelector","innerHTML","selectedChess","emit","id","newLocationX","newLocationY","classList","remove","setState","state","map","chess","instruction","space","selectChess","target","add","validPathCheck","selfCheck","occupiedCheck","array","item","getAdjOccupiedSpaces","adjOccupiedSpaces","nextPossbileMoveCheck","nextValidPathCheck","includes","adjSpaceCheck","parseInt","nextPossbileMove0","nextPossbileMove","forEach","length","checkIfOccupied","checkIfWinner","blackBonusPoints","greenBonusPoints","theSpace","filter","gameOver","handleMove","data","querySelectorAll","boxShadow","transform","console","log","playConnect","pointerEvents","playDisconnect","display","freezeScreen","unFreezeScreen","informRole","player","gameRuleDetail","ruleBtn","blackWinMsg","greenWinMsg","playerConncect","instruTitle","wallPaper","restart","window","reload","this","setInterval","on","positionSpaces","index","onClick","positionChesses","positionZones","zone","gameStart","gameRestart","type","displayRules","Component","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.4785c483.chunk.js","sourcesContent":["import React, {Component, useEffect} from 'react';\nimport './App.css';\nimport io from 'socket.io-client';\n\n// define variable for game playing process\nlet distanceX;\nlet distanceY;\nlet theOriginalX;\nlet theOriginalY;\nlet theMoveToX;\nlet theMoveToY;\nlet occupiedSpaces=[];\nlet adjSpaces = [];\nlet nextValidPath = [];\nlet greenWins = false;\nlet blackWins = false;\nlet activeChesses;\nlet nonActiveChesses;\nlet playerRole;\nlet socket; \nconst endPoint = 'https://react-game-halma.herokuapp.com/';\nsocket= io(endPoint);\n\n\n\n\nclass App extends Component {\n\n  constructor (props){\n    super(props);\n    this.state = {\n      spaces:[],\n      chesses:[],\n      zones:[],\n    }\n\n  }\n\n  // all methods of the app component go in this section\n  getSpaces = () => {\n    let spaces = [];\n    for (let y=1; y<9; y++) {\n      for (let x=1; x<9; x++){\n        spaces.push({\n          className: `space`,\n          value:``,\n          key: `space-${x}-${y}`,\n          location: `(${x},${y})`,\n          locationX: x,\n          locationY: y,\n          isOccupied: false,\n          isValidPath:false,\n          style:{\n            width:`9vh`,\n            height:`9vh`,\n            margin: `0 auto`,\n            borderRadius: `50%`,\n            // border: \"1px solid black\",\n            backgroundColor: \"#F2F2F2\",\n            zIndex:1\n          }\n        })\n      }\n    }\n    return {spaces};\n  }\n\n  getChesses = () => {\n    let chesses = [];\n    let zones =[];\n    for (let y=1; y<5; y++) {\n      for (let x=1; x<(6-y); x++){\n\n        // set up the zones for green area\n        zones.push({\n          key: `zone-${x}-${y}`,\n          // the locationX and locationY needs to be dynamically changed\n          className: `zone greenZone`,\n          locationX: x,\n          locationY: y,\n          currentX: x,\n          currentY: y,\n          style:{\n            width:`9vh`,\n            height:`9vh`,\n            margin: `0 auto`,\n            backgroundColor: \"#B2D977\",\n            zIndex:0,\n            top: `${(y-1)*10+0.5}vh`,\n            left: `${(x-1)*10+0.5}vh`,\n            position:`absolute`,\n          }\n        });\n\n        // set up the chesses for green area\n        chesses.push({\n          key: `chess-${x}-${y}`,\n          // the locationX and locationY needs to be dynamically changed\n          isSelected:false,\n          isMoved:false,\n          className: `chess Green`,\n          value:'Green',\n          OppoValue:'Black',\n          locationX: x,\n          locationY: y,\n          currentX: x,\n          currentY: y,\n          // validPath: [],\n          style:{\n            width:`9vh`,\n            height:`9vh`,\n            margin: `0 auto`,\n            borderRadius: `50%`,\n            // border: \"1px solid black\",\n            backgroundColor: \"green\",\n            zIndex:3,\n            top: `${(y-1)*10+0.5}vh`,\n            left: `${(x-1)*10+0.5}vh`,\n            position:`absolute`,\n            transformOrigin: `${(x-1)*10}vh ${(x-1)*10}vh`\n          }\n        })\n      }\n    }\n\n    for (let y=5; y<9; y++) {\n      for (let x=8; x>(12-y); x--){\n\n        zones.push({\n          key: `zone-${x}-${y}`,\n          // the locationX and locationY needs to be dynamically changed\n          className: `zone blackZone`,\n          locationX: x,\n          locationY: y,\n          currentX: x,\n          currentY: y,\n          style:{\n            width:`9vh`,\n            height:`9vh`,\n            margin: `0 auto`,\n            backgroundColor: \"#8C8C8C\",\n            zIndex:0,\n            top: `${(y-1)*10+0.5}vh`,\n            left: `${(x-1)*10+0.5}vh`,\n            position:`absolute`,\n          }\n        });\n\n        chesses.push({\n          key: `chess-${x}-${y}`,\n          // the locationX and locationY needs to be dynamically changed\n          className: `chess Black`,\n          isMoved:false,\n          isSelected:false,\n          value:`Black`,\n          OppoValue:'Green',\n          locationX: x,\n          locationY: y,\n          currentX: x,\n          currentY: y,\n          // validPath: [],\n          style:{\n            width:`9vh`,\n            height:`9vh`,\n            margin: `0 auto`,\n            borderRadius: `50%`,\n            // border: \"1px solid black\",\n            backgroundColor: \"black\",\n            zIndex:3,\n            top: `${(y-1)*10+0.5}vh`,\n            left: `${(x-1)*10+0.5}vh`,\n            position:`absolute`,\n            // transformOrigin: `(${locationX}-1)vh ${(locationY-1)*10}vh`\n            transformOrigin: `${(x-1)*10}vh ${(y-1)*10}vh`\n          }\n        })\n      }\n    }\n    return {chesses,zones};\n  }\n\n  chessMoveTo = (locationX, locationY, isValidPath) => (e) => {\n      // change the instruction text \n    const instruTitle = document.querySelector('.instruTitle');\n    instruTitle.innerHTML = \n    `<p>Click the chess to see the valid path<p>`;\n\n      // if the space is valid, get the x and y distance and file the animation event\n      theMoveToX = locationX;\n      theMoveToY = locationY;\n      distanceX = (theMoveToX - theOriginalX)*10;\n      distanceY = (theMoveToY - theOriginalY)*10;\n      const selectedChess = document.querySelector(`.selectedChess`);\n      if (selectedChess) {\n        // find out if the clicked space is valid\n        if (isValidPath === true) {\n          socket.emit('chessMove', {\n            id: selectedChess.id,\n            distanceX:distanceX,\n            distanceY:distanceY,\n            newLocationX: theMoveToX,\n            newLocationY: theMoveToY\n          });\n\n          selectedChess.classList.remove('selectedChess');\n            // change the state of the selected Chess, so that the caculation of valid spaces points can be updated\n          this.setState({\n            chesses: this.state.chesses.map((chess)=>{\n              chess.isMoved = false;\n              if(chess.isSelected === true){\n                chess.currentX = locationX;\n                chess.currentY = locationY;\n                chess.isMoved = true;\n              }\n              return chess;\n            }) \n          });\n          \n        // update the instruction and disable chesses \n        const instruction = document.querySelector('.instruction');\n          // find out the one that's being moved\n          this.state.chesses.map((chess)=> {\n            if(chess.isMoved === true) {\n              instruction.innerHTML = `${chess.OppoValue}'s turn!`;\n              activeChesses = `${chess.OppoValue}`;\n              nonActiveChesses = `${chess.value}`;\n            }\n          })\n\n        // update the isValidPath state of spaces\n        this.setState({\n          spaces: this.state.spaces.map((space)=>{\n            space.isValidPath = false;\n            space.className = `space`;\n            return space;\n          })\n        });\n\n        // if one chess is moved, disable its group of chess and enable its opponent chesses\n        this.setState({\n          chesses: this.state.chesses.map((chess) => {\n            if(chess.OppoValue === activeChesses){\n              chess.className = `chess ${nonActiveChesses} disabled`;\n            }else {\n              chess.className = `chess ${activeChesses}`;\n            }\n            return chess;\n          })\n        })\n      }\n\n    } \n    \n\n  }\n\n  selectChess = (key,locationX, locationY, currentX, currentY, value) => (e) => {\n    // change the instruction text\n    const instruction = document.querySelector('.instruction');\n    instruction.innerHTML = `\n                            <p>You can move to an adjacent space or jump over a single adjacent piece<p>\n                            `;\n\n    const instruTitle = document.querySelector('.instruTitle');\n    instruTitle.innerHTML = \"Click on the valid space to move your chess\";\n\n    // indicate which chess is being selected\n    const selectedChess = document.querySelector(`.selectedChess`);\n    if (selectedChess) {\n      selectedChess.classList.remove('selectedChess');\n    }\n    e.target.classList.add('selectedChess');\n\n    // store the current location into global variable\n    theOriginalX = locationX;\n    theOriginalY = locationY;\n\n    // change the state of the chess to indicate this is the one that's being selected\n    this.setState({\n      chesses: this.state.chesses.map((chess)=>{\n        chess.isSelected = false;\n        if(chess.key === key){\n          chess.isSelected = true;\n        }\n        return chess;\n      })\n    });\n\n    // update the isValidPath state of spaces， 每次点击一颗棋子，都要把所有空格的isValidPath先统一改成false\n    this.setState({\n      spaces: this.state.spaces.map((space)=>{\n        space.isValidPath = false;\n        space.className = `space`;\n        return space;\n      })\n    });\n\n    // find out the valid destination spaces\n    this.validPathCheck(currentX, currentY);\n  }\n\n  selfCheck = (x,y) => {\n    if(x>0 && x<9 && y>0 && y<9) {\n      return true;\n    }\n  }\n\n\n  // occupiedCheck to see if the spaces is occupied or not, if not, than make the space valid, if it is occupied, then nothing happend\n  occupiedCheck = (array) => {\n    array.map((item) => {\n      this.setState({\n        spaces: this.state.spaces.map((space)=>{\n            if(space.location === item){\n              // console.log(space);\n              if(space.isOccupied === false) {\n                // validPath.push(space);\n                space.isValidPath = true;\n                space.className = `chess isValidPath`;\n              }\n            }\n            return space\n        })\n      })\n    })\n  }\n\n\n\n\n  getAdjOccupiedSpaces = (array,x,y) => {\n    let adjOccupiedSpaces =[];\n\n    array.map((item) => {\n        this.setState({\n          spaces: this.state.spaces.map((space)=>{\n              if(space.location === item){\n                // console.log(space);\n                if(space.isOccupied === true) {\n                  adjOccupiedSpaces.push(item);\n                }\n              }\n              return space\n          })\n        })\n    })\n\n    this.nextPossbileMoveCheck(adjOccupiedSpaces,x,y);\n\n  }\n\n  // 传入一组墙内的有可能跳进去的目标点，检查这些目标点是否occupied，把空的格子放到一个数组中nextValidPath,对这个数组内的每个格子，设想他们都是棋子，对他们进行下一轮检测\n  nextValidPathCheck = (array) => {\n    \n\n    array.map((item)=>{\n        this.setState({\n          spaces: this.state.spaces.map((space)=>{\n              if(space.location === item){\n                // console.log(space);\n                // 如果空格上没有棋子并且这个空格不是当前已经跳过的路径，那么收入nextValidPath\n                if(space.isOccupied === false && !nextValidPath.includes(item)) {\n                  nextValidPath.push(item);\n                  space.isValidPath = true;\n                  space.className = `chess isValidPath`;\n                  this.adjSpaceCheck(parseInt(item[1]), parseInt(item[3]));\n                  this.getAdjOccupiedSpaces (adjSpaces, parseInt(item[1]), parseInt(item[3]));\n                }\n              }\n              return space\n          })\n        })\n    })\n\n    // console.log(nextValidPath);\n\n  }\n\n  // 传入一组身边的occupied的格子，计算以这些格子为基点，分别怎么跳\n  nextPossbileMoveCheck = (array, x, y) => {\n    let nextPossbileMove0 = [];\n    let nextPossbileMove = [];\n    array.map((item) => {\n      if(item === `(${x-1},${y-1})`){\n        nextPossbileMove0.push(`(${x-2},${y-2})`)\n      }else if(item === `(${x-1},${y})`){\n        nextPossbileMove0.push(`(${x-2},${y})`)\n      }else if(item === `(${x-1},${y+1})`){\n        nextPossbileMove0.push(`(${x-2},${y+2})`)\n      }else if(item === `(${x+1},${y})`){\n        nextPossbileMove0.push(`(${x+2},${y})`)\n      }else if(item === `(${x+1},${y+1})`){\n        nextPossbileMove0.push(`(${x+2},${y+2})`)\n      }else if(item === `(${x+1},${y-1})`){\n        nextPossbileMove0.push(`(${x+2},${y-2})`)\n      }else if(item === `(${x},${y-1})`){\n        nextPossbileMove0.push(`(${x},${y-2})`)\n      }else if(item === `(${x},${y+1})`){\n        nextPossbileMove0.push(`(${x},${y+2})`)\n      }\n    })\n\n    // console.log(`next possible move 0 ${nextPossbileMove0}`);\n\n    // 把墙外的可能的点都淘汰，剩下的都是墙内的可能的点\n    nextPossbileMove0.forEach((item)=>{\n      if(this.selfCheck(parseInt(item[1]), parseInt(item[3]))===true){\n        nextPossbileMove.push(item);\n      }\n    })\n\n    // console.log(`next possible move 1 ${nextPossbileMove}`);\n\n    // 对墙内可能的点，进行occupied排查\n    if(nextPossbileMove.length>0) {\n      this.nextValidPathCheck(nextPossbileMove)\n    }else {\n      return;\n    }\n    \n  }\n  // store the ajacent spaces into adjSpaces\n  adjSpaceCheck = (x,y) => {\n    adjSpaces = [];\n    if(x-1>0) {\n      adjSpaces.push(`(${x-1},${y})`);\n      if(y+1<9){\n        adjSpaces.push(`(${x-1},${y+1})`);\n      }\n      if(y-1>0){\n        adjSpaces.push(`(${x-1},${y-1})`);\n      }\n    }\n\n    if(x+1<9) {\n      adjSpaces.push(`(${x+1},${y})`);\n      if(y+1<9){\n        adjSpaces.push(`(${x+1},${y+1})`);\n      }\n      if(y-1>0){\n        adjSpaces.push(`(${x+1},${y-1})`);\n      }\n    }\n\n    if(y-1>0) {\n      adjSpaces.push(`(${x},${y-1})`);\n    }\n\n    if(y+1<9) {\n      adjSpaces.push(`(${x},${y+1})`);\n    }\n\n    // console.log(adjSpaces);\n\n    // this.getAdjOccupiedSpaces (adjSpaces, x, y);\n  }\n\n  // 在点完棋子后立马运行，而且只运行一次\n  validPathCheck = (x,y) => {\n      \n      let adjOccupiedSpaces = [];\n\n      nextValidPath = [];\n\n      this.adjSpaceCheck (x, y); /*返回adjSpaces[], 不可能是空值 */\n      \n      // check if the spaces in the ajacent spaces is occupied or not, if it's not occuppied, than make it valid, if it's occupied, position the next possible move\n      adjSpaces.map((item) => {\n          this.setState({\n            spaces: this.state.spaces.map((space)=>{\n                if(space.location === item){\n                  // console.log(space);\n                  if(space.isOccupied === false) {\n                    // validPath.push(space);\n                    space.isValidPath = true;\n                    space.className = `chess isValidPath`;\n                  }else{\n                    adjOccupiedSpaces.push(item);\n                  }\n                }\n                return space\n            })\n          })\n      })\n\n      // console.log(adjOccupiedSpaces);\n      // 把附近的occupied的格子储存放到一个数组中，然后计算这颗棋子要以这些格子作为基点分别怎么跳\n      if(adjOccupiedSpaces.length>0){\n        this.nextPossbileMoveCheck(adjOccupiedSpaces,x,y);\n      }else{\n        return;\n      }\n  }\n\n\n // check if the space is occupied or not\n  checkIfOccupied = () => {\n    occupiedSpaces = [];\n    this.state.spaces.map((space)=> {\n        this.state.chesses.map((chess)=>{\n          if(space.locationX === chess.currentX && space.locationY === chess.currentY){\n            occupiedSpaces.push(space);\n            space.value = chess.value;\n          }\n        })\n    });\n\n    this.setState({\n      spaces: this.state.spaces.map((space) => {\n          if (occupiedSpaces.includes(space)) {\n            space.isOccupied = true;\n          } else {\n            space.isOccupied = false;\n          }\n          return space\n      })\n    })\n\n    return occupiedSpaces;\n  }\n\n  // check if we have a winner\n  checkIfWinner = () => {\n    let blackBonusPoints = 0;\n    let greenBonusPoints = 0;\n\n    for (let y=1; y<5; y++) {\n      for (let x=1; x<(6-y); x++){\n          const theSpace = this.state.spaces.filter( space => space.locationX === x && space.locationY === y);\n          // console.log(theSpace);\n          if(theSpace[0].isOccupied && theSpace[0].value === 'Black') {\n            blackBonusPoints ++;\n            // console.log(`blackpionts: ${blackBonusPoints}`);\n\n          }\n      }\n    }\n\n    for (let y=5; y<9; y++) {\n      for (let x=8; x>(12-y); x--){\n          const theSpace = this.state.spaces.filter( space => space.locationX === x && space.locationY === y);\n          // console.log(theSpace);\n          if(theSpace[0].isOccupied && theSpace[0].value === 'Green') {\n            greenBonusPoints ++;\n            // console.log(`greenPoints: ${greenBonusPoints}`);\n          }\n      }\n    }\n\n    if(blackBonusPoints === 10){\n        blackWins = true;\n        this.gameOver();\n        return;\n    }\n\n    if(greenBonusPoints === 10){\n      greenWins = true;\n      this.gameOver();\n      return;\n    }\n    \n  }\n  \n  displayRules() {\n    const gameRuleDetail = document.querySelector('.gameRuleDetail');\n    const ruleBtn = document.querySelector('.ruleBtn');\n    if (gameRuleDetail.style.display === \"none\") {\n      gameRuleDetail.style.display = \"block\";\n      ruleBtn.value = \"HIDE RULES\";\n    } else {\n      gameRuleDetail.style.display = \"none\";\n      ruleBtn.value = \"GAME RULES\";\n    }\n\n  }\n\n  gameStart(e) {\n    const wallPaper = document.querySelector('.wallPaper');\n    const blackWinMsg = document.querySelector('.blackWins');\n    const greenWinMsg = document.querySelector('.greenWins');\n    const playerConncect = document.querySelector('.player-connect');\n    \n    blackWinMsg.style.display = 'none';\n    greenWinMsg.style.display = 'none';\n    playerConncect.style.display = 'none';\n    greenWins = false;\n    blackWins = false;\n\n    // change the text in the instruction cards\n    const instruTitle = document.querySelector('.instruTitle');\n    // socket emmit \n    if(e.target.id === 'greenPlayer'){\n      playerRole = 'Green';\n      socket.emit('gameStart', {\n        player: 'green'\n      });\n      instruTitle.innerHTML = `<p>Your Are Green Player<p>`;\n      document.querySelectorAll('.start').forEach((e) => {\n          e.style.display = 'none';\n      }) \n      document.querySelector('.restart').style.display = 'none';\n      // if it's a green player, freeze the black section\n      document.querySelectorAll('.Black').forEach((e)=> {\n        e.style.pointerEvents = 'none';\n      })\n    }else {\n      playerRole = 'Black';\n      socket.emit('gameStart', {\n        player: 'black'\n      });\n      instruTitle.innerHTML = `<p>Your Are Black Player<p>`;\n      document.querySelectorAll('.start').forEach((e) => {\n          e.style.display = 'none';\n      }) \n      document.querySelector('.restart').style.display = 'none';\n      // if it's a black player, freeze the green section\n      document.querySelectorAll('.Green').forEach((e)=> {\n          e.style.pointerEvents = 'none';\n      })\n    }\n    \n  }\n\n  gameOver() {\n    const wallPaper = document.querySelector('.wallPaper');\n    const blackWinMsg = document.querySelector('.blackWins');\n    const greenWinMsg = document.querySelector('.greenWins');\n    const restart = document.querySelector('.restart');\n\n    wallPaper.style.display = 'flex';\n    restart.style.display = 'block';\n\n    document.querySelectorAll('.start').forEach((e) => {\n      e.style.display = 'none';\n    }) \n\n    if (blackWins) {\n      blackWinMsg.style.display = 'block';\n    }\n    if (greenWins) {\n      greenWinMsg.style.display = 'block';\n    }\n\n  }\n\n  gameRestart() {\n    window.location.reload(false);\n  }\n\n  componentDidMount() {\n    this.setState({\n      ...this.getSpaces(),\n      ...this.getChesses(),\n    });\n\n    // update the isOccupied state of spaces constantly\n    setInterval(this.checkIfOccupied, 100);\n\n    // check winners constantly\n    setInterval(this.checkIfWinner, 100);\n\n    // initilize the content in instruction card\n    const ruleBtn = document.querySelector('.ruleBtn');\n    ruleBtn.value = \"GAME RULES\";\n\n    const instruction = document.querySelector('.instruction');\n    instruction.innerHTML = \"\";\n\n    const instruTitle = document.querySelector('.instruTitle');\n    instruTitle.innerHTML = \n    `<p>Let's Play Halma! <p>`;\n\n    // listerning to socket events -- chess moving \n    socket.on('chessMove', this.handleMove);\n\n    // listerning to socket events -- rival player enter\n    socket.on('player-connect', this.playConnect);\n    \n    // listerning to socket events -- rival player left\n    socket.on('player-disconnect', this.playDisconnect);\n\n    // listerning to socket events -- freezeScreen\n    socket.on('freezeScreen', this.freezeScreen);\n\n    // listerning to socket events -- unfreezeScreen\n    socket.on('unFreezeScreen', this.unFreezeScreen);\n\n    // listerning to socket events -- informRole\n    socket.on('informRole', this.informRole);\n    \n  }\n\n/********************************* define socket events ********************************************************/\nhandleMove = (data) => {\n  document.querySelectorAll(`.chess`).forEach((chess) => {\n      chess.style.boxShadow = \"none\";\n  })\n\n  document.querySelector(`#${data.id}`).style.transform = \"translate3d(\" + data.distanceX + \"vh, \" + data.distanceY + \"vh, 0)\";\n  document.querySelector(`#${data.id}`).style.boxShadow = \"0px 0px 10px 10px orange\";\n  console.log('moved');\n  this.setState({\n        chesses: this.state.chesses.map((chess)=>{\n          chess.isMoved = false;\n          if(chess.key == data.id){\n            chess.currentX = data.newLocationX;\n            chess.currentY = data.newLocationY;\n            chess.isMoved = true;\n            const instruction = document.querySelector('.instruction');\n            instruction.innerHTML = `${chess.OppoValue}'s turn!`;\n            activeChesses = `${chess.OppoValue}`;\n            nonActiveChesses = `${chess.value}`;\n          }\n          return chess;\n        }) \n  });\n\n  this.setState({\n    chesses: this.state.chesses.map((chess) => {\n      if(chess.OppoValue === activeChesses){\n        chess.className = `chess ${nonActiveChesses} disabled`;\n      }else {\n        chess.className = `chess ${activeChesses}`;\n      }\n      return chess;\n    })\n  });\n\n}\n\n  playConnect = () => {\n    document.querySelector('.player-connect').innerHTML = 'The room has two players, ready to start the game';\n    document.querySelector('.blackPlayer').style.pointerEvents = 'auto';\n    document.querySelector('.greenPlayer').style.pointerEvents = 'auto';\n  }\n\n\n  playDisconnect = () => {\n    document.querySelector('.player-connect').style.display = 'block';\n    document.querySelector('.player-connect').innerHTML = 'Your partner player left the room... game stopped';\n    document.querySelector('.wallPaper').style.display = 'flex';\n    document.querySelector('.greenPlayer').style.display = 'none';\n    document.querySelector('.blackPlayer').style.display = 'none';\n    document.querySelector('.restart').style.display = 'block';\n  }\n\n  freezeScreen = ()=> {\n    document.querySelector('.wallPaper').style.display = 'flex';\n    document.querySelectorAll('.start').forEach((e) => {\n        e.style.display = 'none';\n    }) \n    document.querySelector('.restart').style.display = 'none';\n  }\n\n  unFreezeScreen = ()=> {\n    document.querySelector('.wallPaper').style.display = 'none';\n    const instruction = document.querySelector('.instruction');\n    instruction.style.display = 'block';\n    instruction.innerHTML = `${playerRole}'s turn!`;\n  }\n\n  informRole = (data) => {\n    \n    // indicate the opponent user what player option left\n    if(data.player == 'green'){\n        document.querySelector('.greenPlayer').style.display = 'none';\n    }else if (data.player === 'black') {\n      document.querySelector('.blackPlayer').style.display = 'none';\n    }\n  }\n\n  render() {\n    let {spaces, chesses, zones} = this.state;\n    let positionSpaces = spaces.map((space,index)=> { \n      let {key, style, locationX, locationY, className, isValidPath} = space;\n      let reactDom = <div\n          key={key}\n          className={className}\n          onClick={this.chessMoveTo(locationX,locationY, isValidPath)}\n          style={{...style\n          }}\n        >\n        </div >\n      return reactDom;\n    });\n\n    let positionChesses = chesses.map((chess,index)=> { \n      let {key, style, locationX, locationY, currentX, currentY, className, value} = chess;\n      let reactDom = <div\n          value = {value}\n          id = {key}\n          key={key}\n          className={className}\n          onClick={this.selectChess(key,locationX,locationY, currentX, currentY)}\n          style={{...style\n          }}\n        >\n          {/* {key} */}\n        </div >\n      return reactDom;\n    })\n\n    let positionZones = zones.map((zone,index)=> { \n      let {key, style, className} = zone;\n      let reactDom = <div\n          key={key}\n          className={className}\n          style={{...style\n          }}\n        >\n          {/* {key} */}\n        </div >\n      return reactDom;\n    })\n\n    return (\n      <div className=\"App\">\n        <div className=\"wallPaper\">\n          <h1 className=\"greenWins\">Congrats! Green Wins!</h1>\n          <h1 className=\"blackWins\">Congrats! Black Wins!</h1>\n          <button id=\"blackPlayer\" className=\"start blackPlayer\" onClick={this.gameStart}>Play As Black</button>\n          <button id=\"greenPlayer\" className=\"start greenPlayer\" onClick={this.gameStart}>Play As Green</button>\n          <button className=\"restart wallBtn\" onClick={this.gameRestart}>RESTART</button>\n        </div>\n\n        <div className=\"boardWrapper\">\n          <div className=\"board\">\n              {positionSpaces}\n              {positionChesses}\n              {positionZones}\n          </div>\n        </div>\n\n        <div className=\"rule\">\n            <h1 className=\"gameTitle\">Halma</h1>\n            <h3 className=\"player-connect\">Waiting Another Player...</h3>\n            <h1 className=\"instruTitle\"></h1>\n            <div className=\"instruction\"></div>\n            <div className=\"gameRules\">\n              <input className=\"ruleBtn\" type=\"button\" onClick={this.displayRules}></input>\n            </div>\n            <ul className=\"gameRuleDetail\">\n              <li>(i) A piece may be moved to an adjacent square, horizontally, vertically or diagonally;</li>\n              <li>(ii) A piece may jump over a single adjacent piece of any colour, horizontally, vertically or diagonally, into the empty square beyond. Multiple jump over is allowable, as long as it is consistent.</li>\n              <li>(iii) The game is over when a player has moved all of his pieces into his opponent's marked starting positions</li>\n            </ul>\n        </div>\n\n        \n      </div>\n    );\n  }\n  \n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n"],"sourceRoot":""}